//
// SCAMP-5 PE Operation Macros 
//
// Assume analog register F and digital register R0 to be volatile
//
//------------------------------------------------------------------------------

// reset pix to min level
!macro_def
    F.rpix
!macro_begin
    respix
    respix
!macro_end



// $r1 will be a half-toned image, $r2 will be a full range image
!macro_def
    F.rpix($r1,$r2)
!macro_begin
    $r1 = PIX
    F = PIX
    respix
    nop
    $r2 = add($r1,F,PIX)
    $r1 = add(F,PIX)
!macro_end



// carefree copy
!macro_def
    $r1 = F.mov($r2)
!macro_begin
    F = $r2
    $r1 = F
!macro_end

// carefree add
!macro_def
    $r1 = F.add($r2,$r3)
!macro_begin
    F = $r2 + $r3
    $r1 = F
!macro_end

!macro_def
    F.add($r1,$r2)
!macro_begin
    F = $r1 + $r2
    $r1 = F
!macro_end



// carefree subtract
!macro_def
    $r1 = F.sub($r2,$r3)
!macro_begin
    F = $r2
    $r1 = F + $r3
!macro_end

!macro_def
    F.sub($r2,$r3)
!macro_begin
    F = $r2
    $r2 = F + $r3
!macro_end



// carefree negate
!macro_def
    $r1 = F.neg($r2)
!macro_begin
    res(F)
    $r1 = $r2 + F
!macro_end



// carefree abs
!macro_def
    $r1 = F.abs($r2)
!macro_begin
    $r1 = $r2
    F = $r2
    R0 = FLAG
    where($r2)
        $r1 = F
    FLAG = R0
!macro_end



// carefree divide
!macro_def
    F.div($r1,$r2,$r3)
!macro_begin
    div($r1,$r2,$r3)
    F = $r1 + $r3
    $r3 = F + $r2
    div($r3,$r2,F)
    $r2 = F
    $r3 = F
    // under testing
!macro_end



!macro_def
    $r1 = F.in($v)
!macro_begin
    _mov(su,$v)
    _add(su,128)
    _clrc
    set('plrb' 'rid' ) //this drives the bus to zero volts
    _exp(0, IPU_PORT_B)
    _exp(su, IPU_PORT_B)
    $r1 = IN
    $r1 = IN
!macro_end



!macro_def
    $r1 = F.d2a($r2)
!macro_begin
    R0 = FLAG
    all
    set('plrb' 'rid') //this drives the bus to zero volts
    _exp(255,IPU_PORT_B)
    F = IN
    where($r2)
        set('plrb' 'rid') //this drives the bus to zero volts
        _exp(0, IPU_PORT_B)
        F = IN
    all
    $r1 = F
    FLAG = R0
!macro_end



// Digital Register Macros (R0 is volatile)
//------------------------------------------------------------------------------


//
!macro_def
    $r1 = L.not($r2)
!macro_begin
    $r1 = not($r2)
!macro_end


//
!macro_def
    $r1 = L.or($r2,$r3)
!macro_begin
    $r1 = load($r2,$r3)
!macro_end


//
!macro_def
    $r1 = L.nor($r2,$r3)
!macro_begin
    set(xPLRB xNBIT xL$r1 xR$r2 xR$r3) 
!macro_end


//
!macro_def
    $r1 = L.and($r2,$r3)
!macro_begin
    R0 = not($r2) //invert both inputs
    $r2 = not($r3)
    set(xPLRB xNBIT xL$r1 xRFL xR$r2) 
    $r2 = not(R0) //re-instating R$r2
!macro_end


//
!macro_def
    $r1 = L.nand($r2,$r3)
!macro_begin
    R0 = not($r2) //invert both inputs
    $r2 = not($r3) 
    set(xPLRB xBIT xBITMODE xL$r1 xRFL xR$r2) 
    $r2 = not(R0) //re-instating R$r2
!macro_end

